
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>The Beginner's Guide to the UNIXverse</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="author" content="">

        <!-- styles -->
        <link href="./assets/css/bootstrap.min.css" rel="stylesheet">
        <link href="./assets/css/bootswatch.min.css" rel="stylesheet">
        <link href="./assets/css/font-awesome.min.css" rel="stylesheet">
        <link href="./assets/css/shCore.css" rel="stylesheet">
        <link href="./assets/css/shThemeDefault.css" rel="stylesheet">
    </head>

    <body>
        <!-- navigation -->
        <div class="navbar navbar-default navbar-fixed-top">
        <div class="container">
            <div class="navbar-header">
              <a href="" class="navbar-brand">The Beginner's Guide to the UNIXverse</a>
              <button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#navbar-main">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
            </div>
            <div class="navbar-collapse collapse" id="navbar-main">
              <ul class="nav navbar-nav">
                <li>
                  <a href="./">Home</a>
                </li>
                
                
                <li class="dropdown">
                    <a class="dropdown-toggle" data-toggle="dropdown" href="#">Lessons <span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li>
                          <a href="./intro.html">Introduction</a>
                        </li>
                        
                        <li>
                          <a href="./filters.html">UNIX Filters</a>
                        </li>
                        
                        <li class="active">
                          <a href="./regex.html">Regular Expressions</a>
                        </li>
                        
                        <li>
                          <a href="./scripts.html">Shell Scripting</a>
                        </li>
                        
                        
                        <li>
                          <a href="./solutions.html">Solutions</a>
                        </li>
                    </ul>
                </li>
                    
                <li>
                  <a href="./tips.html">Tips</a>
                </li>
              </ul>

              <ul class="nav navbar-nav navbar-right">
                <li><a href="http://compclub.com.au/" target="_blank">CompClub</a></li>
              </ul>

            </div>
            </div>
        </div>

        <!-- content -->
        <div class="container">
            <!-- hello everybody-->
            <div class="jumbotron" style="margin-top: 30px">
                <h1>
                    <span class="fa-stack">
                      <i class="fa fa-square fa-stack-2x"></i>
                      <i class="fa fa-terminal fa-stack-1x fa-inverse"></i>
                    </span>

                    Regular Expressions
                </h1>
            </div>
        
            <div>
                <div class="page-header">
                    <h1>
                        What's a regular expression?
                    </h1>
                </div>
                <p>A <em>regular expression</em> is a pattern to match strings against. (You may see it abbreviated as regex or regexp.)</p>
                <p>Regular expressions are very useful for searching for particular strings that you want. For example, let's say that you have a list of your fellow classmates' names. Let's also say that you hate all Olivers in the world, and want to find out which of your classmates has the name Oliver, so you can take their lunch money. (This approach is a bit flawed, and taking peoples' lunch money is mean, but no matter.)</p>

                <div class="row">
                    <div class="col-md-8">
                        <p>In this case, the pattern you would use would be <code>Oliver</code>. This pattern would simply return everyone who had Oliver in their name. In case it isn't obvious, such a pattern for the list on the right would give back the names -</p>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <strong>Results for pattern <code>Oliver</code></strong>
                            </div>
                            <div class="panel-body">
                                <p>Oliver Fan</p>
                                <p>Oliver Thanh</p>
                                <p>Oliver Petrol</p>
                            </div>
                        </div>
                        <p>Similarly, using a pattern of <code>Pucas</code> would return </p>
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <strong>Results for pattern <code>Pucas</code></strong>
                            </div>
                            <div class="panel-body">
                                <p>Pucas Lickup</p>
                            </div>
                        </div>
                        <p>and so on.</p>
                        <p>
                    </div>
                    <div class="col-md-4">
                        <div class="panel panel-default">
                            <div class="panel-heading">
                                <strong>Sekrit List of Classmates' Names</strong>
                            </div>
                            <div class="panel-body">
                                <p>Pucas Lickup</p>
                                <p>Oliver Fan</p>
                                <p>Mr Inal</p>
                                <p>Doge Superior</p>
                                <p>Oliver Thanh</p>
                                <p>Ke$ha</p>
                                <p>Oliver Petrol</p>
                                <p>Pear Pestephan</p>
                                <p>Lavandar Khan</p>
                                <p>North Best</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="alert alert-info">
                    <i class="fa fa-lightbulb-o"></i> <strong> Note:</strong> In this example, we've used whole first names as a search pattern. However, should we only search for a subsection of a name - for example, <code>liver</code> instead of <code>Oliver</code>, it will still return the same results <strong>DONT LIKE THE WORDING OF THIS</strong>. A string matches a regular expression if the expression is contained in the string.
                </div> 
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Regular Expressions and UNIX
                    </h1>
                </div>
                In UNIX, we can use the <code>grep</code> utility to perform searches for lines matching a regular expression. The basic syntax we use is:
                <p><pre class="brush:bash; gutter:false">$ grep [OPTIONS] PATTERN [FILE]</pre></p>
                <p>We don't have to specify files for it to search against. We can omit the <code>[FILE]</code> option, or instead use a hyphen <code>-</code>. This tells <code>grep</code> to read from standard input. So we can specify a pattern, and then we will be prompted to enter input. After pressing the enter key, grep will print out that line again with matching parts highlighted if it matches the regex you specified.</p>
                

                <div class="row">
                    <div class="col-md-8">
                        <p>Let's return to our example of petty lunch-money-stealing. This time, we'll get <code>grep</code> to do our pattern matching for us. Download the names <a href="./names">here</a>, and save them into a folder you can easily access. Next, open up a terminal (if you don't have one open already) and navigate to the folder containing the file you just downloaded. Now, it's time to enter our command. Our pattern is <code>Oliver</code>, and the file we want to search through is called <code>names</code>. This should be fairly self explanatory:</p>
                        <pre class="brush:bash; gutter:false">$ grep Oliver names</pre>
                        <p>Enter the command. </p>
                        <p>The terminal should give you back results exactly identical to those identified earlier with the same pattern (unless this content's writer is lacking in the head). Note that <code>grep</code> highlights the matching part of the string:</p>
                        <pre>$ grep Oliver names
<strong style="color:red">Oliver</strong> Fan
<strong style="color:red">Oliver</strong> Thanh
<strong style="color:red">Oliver</strong> Petrol</pre>
                        <p>This comes in extremely handy when trying to figure out what's wrong with a pattern that isn't working.</p>
                        <p>If you like, you can add extra names to the <code>names</code> file and verify that <code>grep</code> is indeed working and isn't merely fluking it. You can also change the pattern used and see what output you get!</p>
                    </div>
                    <div class="col-md-4">
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note:</strong> Say that you want to search for someone with a dollar sign in their name. What happens if you use the command <code>grep $ names</code>? Do you get the results you expect?
                        </div>
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note 2:</strong> There is another way you can get <code>grep</code> to search through the specified file. You can use UNIX filters, although in this case it's clearly not very efficient: <code>cat names | grep Oliver</code>. In this case, the contents of <code>names</code> are being sent to standard output, and piped into <code>grep</code>. Since we haven't specified a file for <code>grep</code> to use, it uses the provided text from standard input - in this case, whatever's in <code>names</code>.
                        </div>
                    </div>
                </div>
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Different Flavours of <code>grep</code>
                    </h1>
                </div>
                <p>Let's sidestep for a bit, and take a look at the manpage for <code>grep</code>. Note that there are several variants of <code>grep</code> - some of these you will use, some not:</p>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Program</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>grep</code></td>
                            <td>Our regular ol' regular expression program. (It may interest you to know that it stands for <strong><em>g</em></strong>lobal search and <strong><em>rep</em></strong>lace.)</td>
                        </tr>
                        <tr>
                            <td><code>egrep</code></td>
                            <td>The same thing as if you'd typed <code>grep -E</code>. What's the <code>-E</code>, you ask? It tells <code>grep</code> to interpret the pattern as an extended regular expression - that is, it supports additional expressions in your pattern. More on this later! <strong>This doesn't make sense. Pls fix later myself/someone else.</strong></td>
                        </tr>
                        <tr>
                            <td><code>fgrep</code></td>
                            <td>The same thing as if you'd typed <code>grep -F</code>. The <code>-F</code> flag allows you to specify as a pattern as a list of strings, separated by newlines, any of which is to be matched. (Yes, this was taken straight from the manpage.)</td>
                        </tr>
                        <tr>
                            <td><code>rgrep</code></td>
                            <td>You probably won't use this as often as the others - it will read all the files under each directory recursively.</td>
                        </tr>
                    </tbody>
                </table>
                <div class="row">
                    <div class="col-md-4">
                        <img src="./assets/pictures/perl_camel.jpg" class="img-rounded">
                    </div>
                    <div class="col-md-8">
                        <p>In this lesson, we'll be using extended regular expressions. These give us more features than basic regular expressions, and can make life a bit easier! To use extended regular expressions, as you may have guessed from above, we just need to add the <code>-E</code> option to our command. You can also use <code>egrep</code>, however, its use is deprecated.</p>
                    </div>
                </div>
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Flags
                    </h1>
                </div>
                <p>There are also some very useful flags for <code>grep</code> that we can use. (I won't list them all; you can read the manpage yourself if you're a very keen bean.)</p>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Flag</th>
                            <th>Description</th>
                        </tr> 
                        <tr>
                            <td><code>-i</code></td>
                            <td>This option ignores case when matching - so if you were to specify a pattern</p>
                            <pre class="brush:bash; gutter:false">$ grep -i fresh random_file</pre>
                            <p>then it would find any strings containing the word <code>fresh</code>, whether its letters were capitalised or not.</p>
                            </td>
                        </tr>
                        <tr>
                            <td><code>-v</code></td>
                            <td>Instead of returning all lines that match, it returns all the lines that don't match. So going with the above example, the command </p><pre class="brush:bash; gutter:false">$ grep -v fresh random_file</pre>
                                <p>would return all lines in the file that didn't have fresh in them.</p></td>
                        </tr>
                        <tr>
                            <td><code>-c</code></td>
                            <td>This option will tell <code>grep</code> to output the number of matches for each input file, rather than to output the matching lines themselves.</p></td>
                        </tr>
                    </tbody>
                </table>
                <div class="row">
                    <div class="col-md-6">
                        <div class="panel panel-primary">
                            <div class="panel-heading">
                                <strong>Exercise Eins</strong>
                            </div>
                            <div class="panel-body">
                                <p>Thank god you're here! Oliver's mother has just rung us to tell you that someone has taken his lunch money! She's very upset, and would like someone to find out the names of the classmates who could've taken his money (Oliver refuses to tell her who it was). She knows that it wasn't any of the Olivers, as they're all friends.</p>
                                <p>Write a grep command that finds all the people who could've taken Oliver's lunch money, so the thief can be brought to justice.</p>

                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="panel panel-primary">
                            <div class="panel-heading">
                                <strong>Exercise Zwei</strong>
                            </div>
                            <div class="panel-body">
                                <p>Thank god you're here again! Oliver has just recently acquired an obsession with the word "south". He'd like to find out how many words in the file <code>/usr/share/dict/words</code> contain the word "south" in it, and he doesn't care if some of the letters are capitalised.</p>
                                <p>Write a grep command that counts the number of words in <code>/usr/share/dict/words</code> (you can just use this as the file name - it's included on the computer) which contain the word "south", case-insensitive.</p>
                            </div>
                        </div>
                    </div>
                </div>                
            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Regex Basics
                    </h1>
                </div>
                <div class="row">
                    <div class="col-md-8">
                        <p>Now that <code>grep</code> and friends have been introduced, let's get into the meatiness of regex. In this section, basic expressions for patterns will be introduced. Throughout this lesson, we'll be using <code>/usr/share/dict/words</code>, a file of around 100000 words, to test out our regex patterns.</p>
                        <p>First and foremost, the most intuitive part of regex is that a letter will only match itself. Naturally, if we specify a pattern <code>a</code>, it will match the letter <code>a</code>. If we have a pattern <code>aa</code>, it will match anything containing <code>aa</code>, and so on. This should be highly intuitive.</p>

                        <p>A character matching against itself is all well and good, but leaves a little to be desired. What if you don't care about what a particular character is? Well, happily, there's also a character for that. The <code>.</code> (a full stop) character will match any character. So the pattern <code>.</code> will match any word you compare against it - it matches lines with at least one character in it.</p>
                        


                        <p>Next up are some quantifiers. Quantifiers specify how many of a particular character/group are to be matched.</p>
                    </div>
                    <div class="col-md-4">
                        <div class="alert alert-info">
                            <p><i class="fa fa-lightbulb-o"></i> <strong>Note: </strong>Recall that arguments in bash are passed differently depending on whether there are quotes around them or not. If we do not enclose the pattern in quotes, then the shell will attempt to interpolate variables and special shell metacharacters will be interpreted. This can have interesting (read: frustrating) effects when using these special characters.</p>
                            <p>If we enclose the pattern in single quotes - <code>'I love the $north'</code>, the shell will not touch the pattern. If we enclose it in double quotes - <code>"I love the $north"</code>, the shell will attempt to replace variables (in shell, variables begin with $ when being referenced. In this case, $north will be replaced by its respective value).</p>
                        </div>
                    </div>
                </div>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Character</th>
                            <th>Description</th>
                        </tr> 
                        <tr>
                            <td><code>*</code></td>
                            <td>Putting this after a character tells the regex to match zero or more repetitions of the character. For example, if we test out the pattern <code>t*</code> using the command <code>grep "t*" /usr/share/dict/words</code>, we'll get back the entire file! This is because the asterisk also allows the matching of zero occurrences of the character.</p></td>
                        </tr>
                        <tr>
                            <td><code>+</code></td>
                            <td><p>Sometimes, you don't want to allow a character to be matched zero times. That's okay, there's another character we can use. The <code>+</code> character matches its preceding character 1 or more times. This character is not included in basic regular expressions, so you'll need <code>-E</code> to use this one.</p></td>
                        </tr>
                        <tr>
                            <td><code>?</code></td>
                            <td>This one matches the previous character either once, or not at all. This one's also not part of basic regular expressions.</p></td>
                        </tr>
                    </tbody>
                </table>
                <p>These characters have other functions:</p>
                <table class="table">
                    <tbody>
                        <tr>
                            <th>Character/s</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td><code>()</code></td>
                            <td><p>The parentheses are used for grouping. For example, the pattern <code>a(,a)*</code> accepts comma separated lists of <em>a</em>s.</p></td>
                        </tr>
                        <tr>
                            <td><code>|</code></td>
                            <td>This symbol you may have seen before: it acts as an <em>or</em>. So if you have a pattern <code>north|south</code>, it would accept <code>north</code> or <code>south</code>.</td>
                        </tr>
                    </tbody>
                </table>

            </div>
            <div>
                <div class="page-header">
                    <h1>
                        Anchors
                    </h1>
                </div>
                <p>Now we'll introduce some extremely useful metacharacters - the <code>^</code> and <code>$</code> characters. The caret (<code>^</code>) specifies that whatever follows it <em>must</em> be at the start of the line. So for example, if we wanted to <em>ensure</em> that we search for Oliver as a first name only, then we have the pattern as</p>
                <pre class="brush:bash; gutter:false">$ grep "^Oliver" names</pre>
                <p>The dollar sign (<code>$</code>), in a similar fashion to the caret, specifies that whatever comes before it must be at the end of the word. So if we wanted to only accept lines that had "Oliver" in them, then we would use the command</p>
                <pre class="brush:bash; gutter:false">$ grep "^Oliver$" names</pre>
                <p>(In either of these cases, we didn't need to wrap quotes around the pattern, but it's good practice to just in case your pattern does have characters that can be interpreted by the shell.)</p>
                <p>Let's look at at a couple of examples of anchor usage. Let's say that we want to look for all words that begin with a, end with z, and have at least one character in between them. Then the pattern we'd use would be - (note the <code>-E</code> flag, since we're using an extended regex character)</p>
                <pre class="brush:bash; gutter:false">$ grep -E "^a.+z$" /usr/share/dict/words</pre>
                <p>Oh...there are no results...let's modify our pattern a bit, then. Maybe if we change it to end in y we'd get more results.</p>
                <pre class="brush:bash; gutter:false">$ grep -E "^a.+y$" /usr/share/dict/words
abbey
ability
abjectly
ably
abnormality
...                </pre>
                <p>Woo, that worked! Now let's do a search for words that start with "capt" and end in "ing" (or you can pick a different combination, if you like). Hopefully the pattern here should be obvious:</p>
                <pre class="brush:bash; gutter:false">$ grep -E "^capt.+ing$" /usr/share/dict/words
captaining
captioning
captivating
capturing</pre>
                <p>Hopefully, you should get the same results as we did here.</p>


            </div>

            <div>
                <div class="page-header">
                    <h1>
                        Bracket Expressions
                    </h1>
                </div>
                <p>What's a bracket expression?</p>
                <ul>
                    <li>It's denoted by [<em>list of characters</em>]</li>
                    <li>It will match any single character from the list of characters.</li>
                </ul>
                <p>For example, <code>[aeiou]</code> will match any vowel.</p>
                <div class="row">
                    <div class="col-md-8">
                        <p>You might think that, then, in order to get (for example) the numbers zero to nine, you'd have to go <code>[0123456789]</code> in your pattern. But luckily, there's a nice shorthand for ranges of characters like these - <code>[0-9]</code>. Similarly, you can also use <code>[a-z]</code>, <code>[A-Z]</code> or even <code>[a-m]</code> or another section of the alphabet or numbers. You can even chain them together like <code>[a-zA-Z0-9]</code> - this will match any alphanumeric number.</p>
                        <p>Sometimes, you might want to match any character <em>except</em> anything that's in the list. That's fine! Simply add a <code>^</code> after the first bracket. For example, if I wanted to exclude all the numbers then I would use <code>[^0-9]</code>.</p>
                    </div>
                    <div class="col-md-4">
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note: </strong>One useful range you could use is <code>[ -~]</code> - this will match any printable character.
                        </div>
                        <div class="alert alert-info">
                            <i class="fa fa-lightbulb-o"></i> <strong>Note 2: </strong>Punctuation characters lose their special meaning when they're inside bracket expressions.
                        </div>
                    </div>

                </div>

                <div>
                    <div class="page-header">
                        <h1>
                            Regex Behaviour
                        </h1>
                    </div>
                    <p>Regex behaves in a certain way, and it would be of benefit to you to learn how it does.</p>
                    
                    <p><strong><em>Me first: </em></strong>If a pattern can match multiple parts of the input, then the first match will be chosen. For example if you had a pattern <code>[0-9]+</code> and a string of <code>1234 5678</code>, then it would match the <code>1234</code> and not the <code>5678</code>.</p>

                    <p><strong><em>Greedyguts: </em></strong>By default, regex is <em>greedy</em>. This means that it will try to match as much of the string as possible. Note that with the example in the previous point that it matched as much of it as it could - so, <code>1234</code> instead of <code>1</code>. Simplying matching the <code>1</code> would have been <em>non-greedy</em>. If we wanted a particular quantifier to be non-greedy, we just need to put a question mark after it. So for the previous example, we would have the pattern <code>[0-9]+?</code> and this would match only the <code>1</code>.</p>

                    <p><strong><em>The great escape: </em></strong>Sometimes, you probably won't want the special meaning of <code>[</code>, <code>]</code> or any other special character - you'll want to search for it literally. In this case, you preface the character with a backslash:</p>
                </div>
                                    <pre class="brush:bash">$ echo "[]" > example
$ cat example
[]                                    
$ grep "[]" example
grep: Unmatched [ or [^
$ grep "\[\]" example
[]</pre>
                                    <p>As you can see, searching for the square brackets on their own isn't going to do you any good. However, escaping the respective brackets tells <code>grep</code> to search for a bracket literal. This is the reason why our earlier command <code>grep $ name</code> wasn't very useful.</p>                                      
            <div>
                <h2>Exercises</h2>
                <hr>
                <div class="row">
                    <h4>Less/Grep Practice</h4>
                        <ol>
                            <li>Use Less and its commands to find these words.</li>
                            <ol type="a">
                                <li>What word is on line 2000?</li>
                                <li>Find the first word in the dictionary file ending with z.</li>
                                <li>Find the last word in the dictionary that contains the substring ooz.</li>
                            </ol>
                            <li>There are a small number of English words that have all the vowels occuring in order. Find the first one of these using less, then quit the viewer
                        (q command) and with the same regexp, use grep to find them all. Note: the word may contain more than 5 vowels but it must contain aeiou in that order.</li>
                        <ol type="a">
                            <li>Look at the output from the grep above.What are the first the last and the longest words, which the vowels aeiou in that order?</li>
                            <li>How many are there?</li>
                            <li><em>Challenge</em>, modify the regex so it matches only words containing exactly 5 vowels and the vowels are in order (aeiou).</li>
                        <!--
                        <div style="color:#000099;"><p><b>Answer:</b></p>
                        Command: <tt>grep 'a.*e.*i.*o.*u' mywords</tt> <br>
                        Words:
                        <pre>abstemious
                        ...
                        supercalifragilisticexpialidocious
                        ...
                        valerianaceous
                        </pre>
                        <p>
                        Command: <tt>grep 'a.*e.*i.*o.*u' mywords|wc</tt> <br>
                        </p><pre>     53      53     785
                        </pre>
                        <p>
                        Command: <tt>grep '^[^aeiou]*a[^aeiou]*e[^aeiou]*i[^aeiou]*o[^aeiou]*u[^aeiou]*$' mywords</tt> <br>
                        </p><pre>abstemious
                        abstemiously
                        abstentious
                        arsenious
                        caesious
                        facetious
                        facetiously
                        </pre></div>
                        </li>-->
                        </ol>
                </div>
            </div>

                grep, egrep, regex, eregex, perl regex (use perl regex)

                regex basics
                - ^$
                - . ? *

                regex greedy/non-greedy (e.g. '.*?')


                grep -o -i options


                s// with \1 \2 etc

                examples using find
                e.g. find -R . | grep lol

            <!-- footer -->
            <footer>
                <div class="row">
                    <div class="col-lg-12">         
                        <p class="pull-right"><a href="#"><i class="fa fa-caret-up"></i> Back to top</a></p>
                        <p>Part of the <a href="http://cse.unsw.edu.au/">UNSW CSE</a> Summer Workshops, on behalf of <a href="http://www.compclub.com.au">CompClub</a>.</p>
                        <p>Workshop content written by <a href="http://cgi.cse.unsw.edu.au/~otan/">Oliver Tan</a>, <a href="http://cgi.cse.unsw.edu.au/~vanessau/">Vanessa Ung</a> and <a href="http://cgi.cse.unsw.edu.au/~lpickup">Lucas Pickup</a>.</p>
                    </div>
                </div>
            </footer>

        </div> <!-- container -->

        <script src="./assets/js/jquery.js"></script>
        <script src="./assets/js/bootstrap.min.js"></script>
        <script src="./assets/js/shCore.js"></script>
        <script src="./assets/js/shBrushBash.js"></script>
        <script type="text/javascript">SyntaxHighlighter.all();</script>
    </body>
</html>


